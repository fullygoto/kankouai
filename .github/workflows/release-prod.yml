name: Release to Production

on:
  workflow_dispatch:
  push:
    branches:
      - main
    tags:
      - release/**

permissions:
  contents: write

env:
  RENDER_API_BASE: https://api.render.com/v1

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      prev_sha: ${{ steps.pin.outputs.prev_sha }}
      new_sha: ${{ steps.sha.outputs.new_sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Determine previous production commit
        id: pin
        run: |
          set -euo pipefail
          BRANCH="ops/prod-pin"
          PREV_SHA=""
          if git ls-remote --exit-code origin "$BRANCH" >/dev/null 2>&1; then
            git fetch origin "$BRANCH:$BRANCH" --depth=1
            PREV_SHA=$(git show "$BRANCH:ops/PROD_COMMIT" 2>/dev/null | tr -d '\n' || true)
          else
            echo "No existing ops/prod-pin branch found; using current HEAD as fallback"
          fi
          if [ -z "$PREV_SHA" ]; then
            PREV_SHA=$(git rev-parse HEAD^0)
          fi
          echo "Previous production SHA: $PREV_SHA"
          echo "prev_sha=$PREV_SHA" >> "$GITHUB_OUTPUT"
      - name: Capture new commit
        id: sha
        run: |
          echo "new_sha=$GITHUB_SHA" >> "$GITHUB_OUTPUT"

  tests:
    needs: prepare
    runs-on: ubuntu-latest
    env:
      DATA_BASE_DIR: ${{ runner.temp }}/data
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install dependencies
        run: |
          python -m pip install -U pip
          python -m pip install -r requirements.txt
      - name: Prepare writable data dirs
        run: |
          mkdir -p "$DATA_BASE_DIR/pamphlets" "$DATA_BASE_DIR/system"
      - name: Run pytest
        run: pytest -q

  deploy:
    needs: [prepare, tests]
    runs-on: ubuntu-latest
    env:
      RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      NEW_SHA: ${{ needs.prepare.outputs.new_sha }}
    outputs:
      deploy_id: ${{ steps.trigger.outputs.deploy_id }}
    steps:
      - name: Trigger Render deploy
        id: trigger
        run: |
          set -euo pipefail
          if [ -z "$RENDER_SERVICE_ID" ] || [ -z "$RENDER_API_KEY" ]; then
            echo "RENDER_SERVICE_ID and RENDER_API_KEY must be set" >&2
            exit 1
          fi
          retry() {
            local attempts=$1
            shift
            local count=0
            local delay=2
            until "$@"; do
              exit_code=$?
              count=$((count + 1))
              if [ $count -ge $attempts ]; then
                return $exit_code
              fi
              sleep $((delay ** count))
            done
          }
          body=$(jq -n --arg commit "$NEW_SHA" '{commitId: $commit, clearCache: false}')
          response=$(retry 5 curl --fail-with-body -sS \
            -X POST "$RENDER_API_BASE/services/$RENDER_SERVICE_ID/deploys" \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$body")
          deploy_id=$(echo "$response" | jq -r '.id')
          if [ -z "$deploy_id" ] || [ "$deploy_id" = "null" ]; then
            echo "Failed to obtain deploy ID" >&2
            echo "$response"
            exit 1
          fi
          echo "Triggered deploy $deploy_id for $NEW_SHA"
          echo "deploy_id=$deploy_id" >> "$GITHUB_OUTPUT"
      - name: Wait for deploy to complete
        env:
          DEPLOY_ID: ${{ steps.trigger.outputs.deploy_id }}
        run: |
          set -euo pipefail
          retry() {
            local attempts=$1
            shift
            local count=0
            local delay=2
            until "$@"; do
              exit_code=$?
              count=$((count + 1))
              if [ $count -ge $attempts ]; then
                return $exit_code
              fi
              sleep $((delay ** count))
            done
          }
          while true; do
            response=$(retry 5 curl --fail-with-body -sS \
              "$RENDER_API_BASE/services/$RENDER_SERVICE_ID/deploys/$DEPLOY_ID" \
              -H "Authorization: Bearer $RENDER_API_KEY")
            status=$(echo "$response" | jq -r '.status')
            echo "Deploy status: $status"
            case "$status" in
              live|succeeded)
                break
                ;;
              failed|canceled)
                echo "$response"
                exit 1
                ;;
              *)
                sleep 10
                ;;
            esac
          done

  health-gate:
    needs: [deploy, prepare]
    runs-on: ubuntu-latest
    env:
      PROD_BASE_URL: ${{ secrets.PROD_BASE_URL }}
    steps:
      - name: Wait for /readyz to become healthy
        run: |
          set -euo pipefail
          if [ -z "$PROD_BASE_URL" ]; then
            echo "PROD_BASE_URL is required" >&2
            exit 1
          fi
          retry() {
            local attempts=$1
            shift
            local count=0
            local delay=2
            until "$@"; do
              exit_code=$?
              count=$((count + 1))
              if [ $count -ge $attempts ]; then
                return $exit_code
              fi
              sleep $((delay ** count))
            done
          }
          success=0
          for attempt in $(seq 1 300); do
            if retry 3 curl -fsS "$PROD_BASE_URL/readyz" >/dev/null; then
              echo "readyz healthy on attempt $attempt"
              success=1
              break
            fi
            sleep 2
          done
          if [ "$success" -ne 1 ]; then
            echo "Timed out waiting for /readyz" >&2
            exit 1
          fi
      - name: Smoke test /healthz
        run: |
          set -euo pipefail
          retry() {
            local attempts=$1
            shift
            local count=0
            local delay=2
            until "$@"; do
              exit_code=$?
              count=$((count + 1))
              if [ $count -ge $attempts ]; then
                return $exit_code
              fi
              sleep $((delay ** count))
            done
          }
          retry 5 curl -fsS "$PROD_BASE_URL/healthz" >/dev/null

  pin-update:
    needs: [prepare, deploy, health-gate]
    if: ${{ needs.health-gate.result == 'success' }}
    runs-on: ubuntu-latest
    env:
      NEW_SHA: ${{ needs.prepare.outputs.new_sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Update production pin
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git checkout -B ops/prod-pin
          echo "$NEW_SHA" > ops/PROD_COMMIT
          if git diff --quiet; then
            echo "PROD_COMMIT already up to date"
            exit 0
          fi
          git commit -am "chore: pin production to $NEW_SHA"
          git push origin ops/prod-pin

  rollback:
    needs: [prepare, deploy, health-gate]
    if: ${{ needs.health-gate.result == 'failure' }}
    runs-on: ubuntu-latest
    env:
      RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      PROD_BASE_URL: ${{ secrets.PROD_BASE_URL }}
      PREV_SHA: ${{ needs.prepare.outputs.prev_sha }}
    steps:
      - name: Trigger rollback deploy
        id: rollback
        run: |
          set -euo pipefail
          if [ -z "$PREV_SHA" ]; then
            echo "Previous SHA is not set" >&2
            exit 1
          fi
          retry() {
            local attempts=$1
            shift
            local count=0
            local delay=2
            until "$@"; do
              exit_code=$?
              count=$((count + 1))
              if [ $count -ge $attempts ]; then
                return $exit_code
              fi
              sleep $((delay ** count))
            done
          }
          body=$(jq -n --arg commit "$PREV_SHA" '{commitId: $commit, clearCache: false}')
          response=$(retry 5 curl --fail-with-body -sS \
            -X POST "$RENDER_API_BASE/services/$RENDER_SERVICE_ID/deploys" \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$body")
          deploy_id=$(echo "$response" | jq -r '.id')
          if [ -z "$deploy_id" ] || [ "$deploy_id" = "null" ]; then
            echo "Failed to obtain rollback deploy ID" >&2
            echo "$response"
            exit 1
          fi
          echo "Triggered rollback deploy $deploy_id for $PREV_SHA"
          echo "deploy_id=$deploy_id" >> "$GITHUB_OUTPUT"
      - name: Wait for rollback deploy to complete
        env:
          DEPLOY_ID: ${{ steps.rollback.outputs.deploy_id }}
        run: |
          set -euo pipefail
          retry() {
            local attempts=$1
            shift
            local count=0
            local delay=2
            until "$@"; do
              exit_code=$?
              count=$((count + 1))
              if [ $count -ge $attempts ]; then
                return $exit_code
              fi
              sleep $((delay ** count))
            done
          }
          while true; do
            response=$(retry 5 curl --fail-with-body -sS \
              "$RENDER_API_BASE/services/$RENDER_SERVICE_ID/deploys/$DEPLOY_ID" \
              -H "Authorization: Bearer $RENDER_API_KEY")
            status=$(echo "$response" | jq -r '.status')
            echo "Rollback deploy status: $status"
            case "$status" in
              live|succeeded)
                break
                ;;
              failed|canceled)
                echo "$response"
                exit 1
                ;;
              *)
                sleep 10
                ;;
            esac
          done
      - name: Wait for readiness after rollback
        run: |
          set -euo pipefail
          retry() {
            local attempts=$1
            shift
            local count=0
            local delay=2
            until "$@"; do
              exit_code=$?
              count=$((count + 1))
              if [ $count -ge $attempts ]; then
                return $exit_code
              fi
              sleep $((delay ** count))
            done
          }
          success=0
          for attempt in $(seq 1 300); do
            if retry 3 curl -fsS "$PROD_BASE_URL/readyz" >/dev/null; then
              echo "readyz healthy after rollback on attempt $attempt"
              success=1
              break
            fi
            sleep 2
          done
          if [ "$success" -ne 1 ]; then
            echo "Rollback readiness check failed" >&2
            exit 1
          fi
          retry 5 curl -fsS "$PROD_BASE_URL/healthz" >/dev/null
      - name: Mark workflow as failed after rollback
        run: |
          echo "Health gate failed; rolled back to $PREV_SHA" >&2
          exit 1
